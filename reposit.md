[< к содержанию](readme.md)

## Работа в репозитории

Как правило, есть два варианта начать работу с репозиторием *Git*:
1. Можно выбрать локальный каталог и создать новый репозиторий в нем.

2. Можно клонировать существующий репозиторий с локального компьютера или сервера. Обычно проекты клонируются именно с сервера.

Если у вас на компьютере уже есть рабочий проект, но еще не назначен контроль версий, то нужно сначала перейти в каталог проекта.

Linux:
```
> cd /home/user/SomeConsoleApp
```
macOS:
```
> cd /Users/user/SomeConsoleApp
```
Windows:
```
> cd C:/Users/user/SomeConsoleApp
```
Инициализируем репозиторий:
```
> git init
```
Команда создаст каталог с именем **.git**, в котором будут храниться структурные файлы репозитория. 

И, наконец, нужно добавить под контроль версий все существующие файлы командой **git add .** (точка в конце важна!). Можно добавлять и по одному файлу, с помощью **git add <имя файла>**. 

Заодно создадим начальный коммит командой **git commit**:
```
> git add readme.md
> git commit -m 'Initial project version'
```
Команду **git add** можно гибко настраивать с помощью дополнительных параметров (флагов), которые подробно описаны в официальной документации: https://git-scm.com/docs/git-add. К примеру, команда **git add —force** добавит даже игнорируемые файлы, а **git add —update** позволит обновить отслеживаемые файлы.

В этом репозитории вы можете продолжать работать и дальше, со временем обновляя его и отправляя рабочие версии на сервер.

### Клонирование существующего репозитория

Когда вы работаете в команде, разрабатываемые проекты часто размещают на сервере. Это один из самых распространенных сценариев. Вам нужно получить копию проекта последней версии на свой компьютер, чтобы далее вносить в него свой вклад.

В качестве примера мы будем рассматривать проект, который создадим на ресурсе https://github.com/ . После регистрации на сайте и подтверждения по **e-mail** нужно создать новый репозиторий, как показано на скриншотах.

![new repository](/assets/image2.png)

![repository](/assets/12.png)

Видно, что можно выбрать тип репозитория:

* публичный (public) – доступ открыт для любого пользователя, однако права на редактирование выдает владелец проекта;
* приватный/скрытый (private) — проект виден только владельцу, другие участники добавляются вручную.

Для нашего примера создадим приватный репозиторий под названием *SomeConsoleApp* и будем работать с ним далее.

Самые удобные способы клонирования проекта — через протоколы HTTP и SSH, прочесть обо всех более развёрнуто можно по ссылке: https://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols.

Для наших целей воспользуемся протоколом https и следующей командой:
```
> git clone https://github.com/ErdemBalzhinimaev/12.git
```

На вашем компьютере в каталоге, куда вы перешли в командной строке, должен появиться каталог **12**, внутри него — каталог **.git** и все скачанные файлы репозитория последней версии.

После получения проекта обычно начинается более рутинный рабочий процесс — правки, добавление функционала и т. д. Далее в какой-то момент вы захотите сохранить прогресс в новой версии проекта.

Правила и периодичность обновления могут быть почти любыми, но хорошим тоном обычно считается сохранять рабочую (или промежуточно завершенную) версию. Важное требование для команд разработчиков — возможность сборки проекта, иначе другие участники команды будут вынуждены тратить время на борьбу с ошибками компиляции.

### Сохранение снимков и просмотр статуса проекта

Как упоминалось ранее, часть файлов в рабочем каталоге может и не находиться под контролем версий. За отслеживаемыми файлами «наблюдает» *Git*, они были как минимум в прошлом снимке состояния проекта. Неотслеживаемыми могут быть, например, вспомогательные файлы в рабочем проекте, если они не зафиксированы в прошлой версии проекта и не готовы к коммиту. Их можно выделить в отдельную категорию для *Git*, о чем будет рассказано далее.

Сразу после клонирования все файлы проекта будут отслеживаемыми. Отредактировав их и привнеся что-то новое, вы индексируете (stage) и фиксируете (commit) правки, и так для каждой версии проекта.

При этом нужно внимательно следить, чтобы вспомогательные файлы, особенно объемные, оставались вне контроля версий. Если по недосмотру добавить их в коммит и отправить на сервер — вероятнее всего, ваши правки придется частично откатывать.

Проверить состояние файлов в рабочем каталоге можно командой **git status**. После клонирования консоль выведет примерно такую информацию:
```
On branch master
Your branch is up to date with ‘origin/master’.

nothing to commit, working tree clean
```
Теперь отредактируем файлы (в этом примере было консольное демо-приложение, созданное с помощью Visual Studio) и сравним статус:
```
>git status
On branch master
Your branch is up to date with ‘origin/master’.
Untracked files:
(use “git add <file>...” to include in what will be committed)
	Program.cs
	12.csproj
	12.sln
nothing added to commit but untracked files present (use “git add” to track)
```
Теперь зафиксируем изменения. В коммит войдут только те файлы, которые вы изменили и добавили командой **git add**. Остальные будут лишь дополнительными файлами в каталоге проекта.

Стандартный способ — команда **git commit**, которую мы уже видели раньше. Без дополнительных аргументов она откроет встроенный текстовый редактор, поэтому для простоты рекомендуется добавить аргумент **-m** и вписать комментарий в кавычках:
```
> git commit -m "Task 2: basic project template added"
```
Для удаления ненужных файлов из репозитория можно использовать команду **`git rm <file-name>`**. Файл также пропадет из рабочего каталога. Выполнить коммит необходимо и в этом случае; до тех пор структура проекта не изменится.

### Управление удаленными репозиториями

Просмотреть список текущих онлайн-репозиториев можно командой **git remote**. Добавить другие — с помощью команды **git remote add `<shortname> <url>`**, например:
```
>git remote add myDemo https://github.com/DanZDev2/DemoApp
>git remote
myDemo
origin
```

### Отправка изменений в удаленный репозиторий (Push)

На вашем компьютере есть проект со внесенными изменениями, но вы хотите поделиться новой версией со всей командой. 

Команда для отправки изменений на сервер такова: **git push `<remote-name> <branch-name>`**. Если ваша ветка называется *master*, то команда для отправки коммитов станет такой:
```
> git push origin master
```
Она сработает, если у вас есть права на запись на том сервере, откуда вы клонировали проект. Также предполагается, что другие участники команды за это время не обновляли репозиторий.

Следует к тому же помнить, что в разработке для промежуточных правок часто используется не главная ветка (master), а одна из параллельных (например, Dev). Работая в команде, этому обязательно нужно уделять пристальное внимание.

### Получение изменений из репозитория (Pull)

Самый простой и быстрый способ получить изменения с сервера — выполнить команду git pull, которая извлечет (fetch) данные с сервера и попытается встроить/объединить (merge) их с вашей локальной версией проекта. 

На этом этапе могут возникать конфликты версий, когда несколько человек поработали над одними и теми же файлами в проекте и сохранили свои изменения. Избежать этого можно, если изолировать части проекта, поручив работу над одной частью только одному человеку. Разумеется, на практике это не всегда выполнимо, поэтому в Git есть инструменты для разрешения конфликтов версий. Они будут рассмотрены далее.