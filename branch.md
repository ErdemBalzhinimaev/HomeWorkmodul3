[< к содержанию](readme.md)

## Ветвление в Git 

Почти каждая система контроля версий (СКВ) в какой-то форме поддерживает ветвление. Используя ветвление, Вы отклоняетесь от основной линии разработки и продолжаете работу независимо от неё, не вмешиваясь в основную линию. Во многих СКВ создание веток — это очень затратный процесс, часто требующий создания новой копии каталога с исходным кодом, что может занять много времени для большого проекта.

Некоторые люди, говоря о модели ветвления *Git*, называют ее «киллер-фича», что выгодно выделяет *Git* на фоне остальных СКВ. Что в ней такого особенного? Ветвление *Git* очень легковесно: операция создания ветки выполняется почти мгновенно, переключение между ветками туда-сюда, обычно, также быстро. В отличие от многих других СКВ, *Git* поощряет процесс работы, при котором ветвление и слияние выполняется часто, даже по несколько раз в день. Понимание и владение этой функциональностью дает вам уникальный и мощный инструмент, который может полностью изменить привычный процесс разработки.

Создадим две дополнительные ветки *Dev* и *Test* (например, одна может пригодиться для процесса разработки, а другая — для запуска в тестирование). Введем команду **`git branch <branch-name>`** дважды с разными аргументами: 
```
>git branch Dev
>git branch Test
```
Ветки созданы, но мы по-прежнему работаем в *master*. Для переключения на другую нужно выполнить **`git checkout <branch-name>`**:
```
>git checkout Dev
Switched to branch ‘Dev’
Your branch is up to date with ‘origin/Dev’.
```
Внесем некоторые изменения в файл **README.md** и зафиксируем их, чтобы они отразились в ветке *Dev*:

```
>git add .
>git commit -m “dev readme changed”
[Dev #####] dev readme changed
1 file changed, 2 insertions(+)
```
Если теперь отправить их на сервер, то можно убедиться в появившемся отличии веток.

Для переключения обратно на ветку *master* нужно снова ввести команду **git checkout master**. Она не изменялась, а значит, после редактирования проекта ветки разойдутся. Это нормальная ситуация для проектов в *Git*. Важно только понимать, для каких целей используется каждая из веток, и не забывать вовремя переключаться между ними.

### Слияние веток (merge)
Работа над проектами часто ведется в несколько этапов, им могут соответствовать ветки (в нашем примере Dev → Test → master). Отдельные ветки могут создаваться для срочного исправления багов, быстрого добавления временных функций, для делегирования части работы другому отделу и т. д. Предположим, что нужно применить изменения из ветки Dev, внеся их в master. Перейдем в master и выполним команду `git merge <source-branch>`:
```
>git merge Dev
Updating #####..#####
Fast-forward
README.md | 2 +-
1 file changed, 1 insertion(+), 1 deletion(-)
```

Изменения успешно перенесены. В наших упрощенных условиях команда завершилась без ошибок, не найдя конфликтов в файлах. Если же над общими участками какого-либо файла успели поработать несколько человек, с этим нужно разбираться вручную. При возникновении ошибок *Git* помечает общие части файлов из разных веток и сообщает о конфликте.

Для разрешения конфликтов есть консольная утилита **git mergetool**. Однако если файл проекта объемный, а общих частей много, пользоваться ей не слишком удобно. Общая рекомендация для таких случаев — пользоваться сторонними инструментами, как и в случае с текстовым редактором для *Git*.

Когда спорные участки всех файлов приведены к итоговому состоянию, нужно повторить стандартную процедуру: создать коммит и отправить их командой push в нужную ветку в репозитории.

Дальнейшая работа с проектом из репозитория *Git*, как правило, повторяется по алгоритму:
* pull (забрать изменения с сервера);
* внести правки, добавить что-то важное в проекте;
* add (добавить изменённые файлы к коммиту);
* commit (сохранить состояние проекта с комментариями);
* push (отправить изменения на сервер).
* merge (при необходимости внедрить изменения из другой ветки проекта).